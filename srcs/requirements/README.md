# Docker

**Docker**는 애플리케이션과 그 실행에 필요한 모든 종속성을 하나의 패키지로 묶어 **컨테이너**(Container)라는 가벼운 가상 환경에 격리하여 실행할 수 있게 하는 플랫폼이다. 컨테이너는 운영
체제의 커널을 공유하면서 독립된 실행 환경을 제공하여, 가상 머신(VM)보다 빠르고 자원을 적게 사용하면서도 높은 이식성과 확장성을 보장한다.

- **장점**
    - 이식성: "Write Once, Run Anywhere" 원칙에 따라, 개발 환경과 배포 환경의 차이로 인한 문제를 줄여준다.
    - 효율성: VM보다 가벼워서 빠르게 시작하고 자원을 적게 사용한다.
    - 확장성: 여러 컨테이너를 쉽게 관리하고 오케스트레이션 도구(Kubernetes 등)와 통합하여 확장할 수 있다.
    - 버전 관리: 특정 이미지 버전을 생성하고 관리할 수 있어, 애플리케이션의 특정 버전을 쉽게 재현할 수 있다.

## Docker의 가상 머신(VM) 대비 장점

1. 자원 효율성 및 성능
    - 운영 체제 커널 공유: Docker는 호스트 운영 체제의 커널을 공유하는 방식으로 컨테이너를 실행한다. 각 컨테이너는 애플리케이션 코드와 필수 라이브러리만 포함하고 있으며, 별도의 운영 체제 전체를
      실행할 필요가 없기 때문에 VM보다 메모리와 디스크 자원을 훨씬 적게 사용한다.
    - 더 빠른 실행 및 종료: VM은 각각의 가상 머신마다 운영 체제를 부팅해야 하므로 시간이 오래 걸리지만, Docker 컨테이너는 호스트 OS에서 직접 프로세스로 실행되므로 훨씬 더 빠르게 시작하고 종료할
      수 있다. 일반적으로 Docker 컨테이너는 몇 초 안에 시작할 수 있지만, VM은 부팅 시간 때문에 몇 분이 걸릴 수 있다.
2. 높은 이식성
    - 일관된 실행 환경: Docker 이미지를 통해 특정 환경에서 작동하도록 패키징되므로, 어느 호스트에서 실행하더라도 동일한 환경을 유지할 수 있다. 반면 VM은 각 하이퍼바이저(VM을 운영하는
      소프트웨어)나 호스트 운영 체제의 설정에 따라 환경이 달라질 수 있어 이식성에 제한이 있다.
    - 운영 체제에 독립적: Docker 컨테이너는 호스트 운영 체제와 관계없이 다양한 환경에서 동일하게 작동한다. Docker 이미지를 사용하면 Windows, Mac, Linux 어디서든지 동일한 실행
      환경을 재현할 수 있어 개발자나 DevOps 팀이 환경 차이로 인한 오류를 줄일 수 있다.
3. 비용 절감 및 효율적인 자원 분배
    - 더 많은 애플리케이션 밀도: Docker는 동일한 하드웨어 자원에서 여러 컨테이너를 효율적으로 실행할 수 있어, VM보다 더 많은 애플리케이션을 동시에 운영할 수 있다. 이는 데이터 센터나 클라우드
      환경에서 VM보다 자원을 효율적으로 사용할 수 있게 해 준다.
    - 자원 할당 유연성: Docker 컨테이너는 필요할 때 쉽게 추가하거나 제거할 수 있어, 애플리케이션의 확장성과 유연성이 뛰어나다. VM은 리소스 확장 시 시간이 오래 걸리고 자원을 과도하게 소모할 수
      있지만, Docker는 컨테이너 단위로 자원을 조정하므로 더 유연하게 사용할 수 있다.

## init 프로세스

**init 프로세스**는 리눅스 및 유닉스 시스템에서 가장 먼저 실행되는 프로세스로, 모든 프로세스의 부모 역할을 한다. 시스템이 부팅될 때 커널이 먼저 실행된 후, 커널은 가장 먼저 init 프로세스를 시작한다.
init 프로세스는 PID 1을 가지며, 시스템 내에서 프로세스 관리, 시스템 종료, 프로세스 재시작 및 모니터링 등의 역할을 수행한다.

주요 역할:

- 프로세스 관리: 자식 프로세스들이 종료되었을 때 그들의 종료 상태를 처리
- 시스템 종료 처리: 시스템이 종료될 때, 종료된 프로세스를 처리하고 시스템을 안전하게 종료
- 시그널 처리: 시스템에서 발생하는 시그널을 받아서 각 프로세스에 전달

## 도커 컨테이너에서 PID 1 문제

컨테이너는 일반적으로 최소화된 환경으로, 운영 체제의 여러 부분이 잘려나가고 단일 프로세스가 실행된다. 이때, 컨테이너 내에서 실행되는 프로세스는 PID 1을 가지게 된다. 그러나 Docker와 같은 컨테이너
환경에서는 기본적으로 PID 1 역할을 하는 프로세스가 init 프로세스처럼 작동하지 않는다. 이는 다음과 같은 문제를 야기할 수 있다.

- **좀비 프로세스**: PID 1 프로세스는 자식 프로세스가 종료된 후, 그 상태를 확인하고 자원을 해제하는 역할을 해야 한다. 그러나 일반적으로 애플리케이션 프로세스는 이러한 역할을 하지 않으며, 따라서
  종료된 자식 프로세스의 상태를 수집하지 않으면 자식 프로세스는 좀비 상태로 남게 된다. (좀비 프로세스는 종료된 상태지만 여전히 시스템 자원을 차지하고 있는 상태의 프로세스를 의미)
- **시그널 처리 문제**: PID 1은 시스템 시그널을 제대로 처리해야 하는데, 컨테이너 내에서 실행되는 PID 1 프로세스는 시그널을 제대로 처리하지 않는 경우가 많습니다. 예를 들어, `SIGTERM`(
  프로세스 종료 요청) 시그널을 처리하고 프로세스를 안전하게 종료하는 것은 중요한 작업이지만, 일반적인 애플리케이션 프로세스는 시그널 처리에 최적화되지 않은 경우가 많습니다.

## Tini

`tini`는 이러한 문제를 해결하기 위해 만들어진 간단한 프로세스 관리자이다. `tini`는 컨테이너의 PID 1로 실행되어, 다음과 같은 주요 기능을 제공한다:

- 좀비 프로세스 처리: `tini`는 자식 프로세스들이 종료된 후 그들의 종료 상태를 처리하여 좀비 프로세스가 남지 않도록 한다. 이를 통해 시스템 리소스를 낭비하지 않고, 컨테이너의 안정성을 유지할 수 있다.
- 시그널 전달: `tini`는 컨테이너가 종료될 때 (예: `docker stop` 명령어) 시그널을 자식 프로세스에게 적절히 전달하여, 자식 프로세스가 정상적으로 종료될 수 있도록 돕는다. 이 기능은 컨테이너가
  종료되거나 재시작될 때 중요한 역할을 한다.
- 컨테이너 안정성 향상: `tini`는 매우 작은 크기로 설계되어 성능에 큰 영향을 미치지 않으면서도, 프로세스 관리 기능을 제공한다.

```dockerfile
# 예시

FROM ubuntu:latest

ENTRYPOINT ["/usr/bin/tini", "--"]

CMD ["your-application"]
```

위와 같이 `ENTRYPOINT`를 `/usr/bin/tini --`로 지정하면, `tini`가 컨테이너의 init 프로세스로 설정되고, `CMD`로 설정된 애플리케이션을 자식 프로세스로 실행하여 관리하게 된다.

## Docker 명령어

- `ENTRYPOINT`
    - 컨테이너가 항상 실행해야 하는 주요 명령어
- `CMD`
    - 기본 명령어 또는 인수
    - `ENTRYPOINT`가 있을 경우 기본 인수 역할을 하며, `ENTRYPOINT`가 없으면 컨테이너가 실행될 때의 기본 명령어로 사용
